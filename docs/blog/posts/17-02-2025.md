---
title: "Introduction to Nuclei Templates"
summary: "Basic explanation of Nuclei templates"
date: 2025-02-16
tag:
  - Cybersecurity
  - Pentesting
  - Nuclei
  - Automation
  - Template
---

# How Nuclei Templates Work

In this practical article, we will delve into how **Nuclei** templates work, a fast and modular vulnerability scanning tool. You will learn how to create, configure, and execute your own templates to automate vulnerability detection, saving you time on manual tasks and adapting the scan to specific scenarios.

<!-- more -->

---

## What is a Nuclei Template?

A Nuclei template is a YAML-formatted file that defines:

- **Basic Information:** Identifier, name, author, severity, and description.
- **Requests:** Configuration of the HTTP request (or another protocol) that will be sent to the target.
- **Matchers:** Conditions that must be met in the response to determine if the vulnerability is present.
- **Extractors (Optional):** Tools to extract additional information from the response.

These templates allow you to standardize and automate vulnerability detection without having to rewrite code each time.

---

## 1. Information Block (info)

This block is used to document and categorize the template. Here you can define:

- **id:** A unique identifier for the template.
- **name:** The human-readable name of the template.
- **author:** The author or authors responsible for the template.
- **severity:** The criticality of the vulnerability (e.g., low, medium, high, critical).
- **description:** A detailed description of what the template does and which vulnerability it detects.
- **reference:** Links to documentation, CVEs, or external resources that support the vulnerability.
- **tags:** Labels that facilitate the search and categorization of the template.

_Example:_

```yaml
info:
  id: example-vulnerability
  name: "Example of Generic Vulnerability"
  author: "YourName"
  severity: "medium"
  description: "This template detects a generic vulnerability in a web application."
  reference:
    - "https://example.com/vulnerability-details"
  tags: ["example", "web", "vulnerability"]
```

---

## 2. Request Definition

The core of a template is the definition of the requests that will be sent to the target. Here you can configure:

- **method:** The HTTP method (GET, POST, PUT, DELETE, etc.) or the corresponding method for other protocols.
- **path:** The path or paths where the requests will be sent. You can use variables (such as `{{BaseURL}}`) to dynamically set the endpoint.
- **headers:** Allows you to define custom HTTP headers. This is useful to simulate different types of clients, manage cookies, or authenticate the request.
- **body:** The content of the request (very useful for POST or PUT methods). You can define the body in different formats (JSON, XML, form data, etc.).
- **timeout and retries:** Options to configure the timeout and the number of retries in case a response is not received.

_Example:_

```yaml
requests:
  - method: POST
    path:
      - "{{BaseURL}}/api/login"
    headers:
      Content-Type: "application/json"
      User-Agent: "Mozilla/5.0 (compatible; Nuclei)"
    body: '{"username": "admin", "password": "admin"}'
    timeout: 5
    retries: 2
```

---

## 3. Use of Variables and Placeholders

Nuclei allows the use of variables in your templates to make them more flexible and reusable. Some possibilities include:

- **Predefined variables:** Such as `{{BaseURL}}`, which is automatically replaced by the target.
- **Custom variables:** You can define your own variables within the template to reuse values in multiple sections (for example, URLs, tokens, or parts of the request body).

This functionality allows you to create more dynamic templates that can adapt to different scenarios without having to edit the code every time.

---

## 4. Payloads

*Payloads* are one of the most powerful features of Nuclei for performing injection tests or brute-force on parameters. With payloads you can:

- **Define lists of values:** For example, different strings, special characters, or patterns to test in a parameter.
- **Iterate over each value:** Nuclei will execute the request for each defined payload, allowing you to cover a wide range of possibilities in a single template.

_Example:_

```yaml
payloads:
  usernames:
    - admin
    - root
    - test
```

Then, in the body or the URL, you can reference the payload with the syntax `{{payload}}` or `{{username}}` if you define it with a specific name.

---

## 5. Matchers

Matchers are essential for determining whether the server's response indicates the presence of a vulnerability. Nuclei offers several options:

- **Status Matcher:** Checks that the response has a specific HTTP status code (e.g., 200, 404).
- **Word Matcher:** Searches for specific strings in the response body.
- **Regex Matcher:** Uses regular expressions to search for complex patterns.
- **Size Matcher:** Validates that the content size is within an expected range.
- **Header Matcher:** Allows you to evaluate if certain headers are present or have a specific value.
- **JSON Matcher:** Especially useful for responses in JSON format, it allows you to validate specific keys and values.

Additionally, you can combine multiple matchers and use the `condition` option to determine whether all (AND) or at least one (OR) must be met.

_Example:_

```yaml
matchers:
  - type: status
    status:
      - 200
  - type: word
    words:
      - "vulnerable-string"
    condition: and
```

---

## 6. Extractors

Extractors are tools to extract specific information from the response, which is very useful for enriching vulnerability reports or chaining results across multiple steps. Some options are:

- **Regex Extractor:** Extracts data using regular expressions.
- **JSON Extractor:** Extracts values from specific keys in JSON responses.
- **HTML Extractor:** Can extract information from HTML documents (for example, titles, meta tags).

_Example:_

```yaml
extractors:
  - type: regex
    regex:
      - "user: ([a-zA-Z0-9]+)"
```

This extractor will search for patterns matching `user: something` and extract the value, which can be used to identify usernames or tokens in the response.

---

## 7. Advanced Features and Additional Options

### Multiple Requests and Sequential Steps

- **Multi-step workflows:** You can chain multiple requests within a single template. This is useful when you need to perform a preliminary step (such as authentication) before executing the main check.
- **Conditional requests:** Requests can be conditioned based on previous results, allowing for more complex workflows.

### Including Custom Scripts

- **Inline scripts:** Some templates allow you to include scripts (for example, in JavaScript or another compatible language) to perform checks or transform the response beyond basic matchers.
- **Operators and functions:** You can apply functions or manipulations to the extracted values to compare or transform them according to the test logic.

### Connection Settings

- **Redirections:** Configure redirection handling, such as defining a maximum number of redirections or following them automatically.
- **Certificates and SSL:** Options to validate SSL certificates or ignore warnings in testing environments.

### Customization with Environment Variables

- **External variables:** You can integrate variables defined in your environment (for example, via the command line) to further parameterize the template. This is especially useful in CI/CD pipelines.

---

## 8. Complete Example of an Advanced Template

As a summary, here is an example that integrates several of the possibilities discussed:

```yaml
id: advanced-example
info:
  name: "Advanced Template Example"
  author: "authorName"
  severity: "high"
  description: "This template executes a multi-step workflow with advanced payloads and extractors."
  reference:
    - "https://example.com/advanced-vulnerability"

payloads:
  test-param:
    - "admin"
    - "root"
    - "test"

requests:
  - method: GET
    path:
      - "{{BaseURL}}/api/data?user={{test-param}}"
    headers:
      User-Agent: "Nuclei-Attack"
    timeout: 10
    matchers:
      - type: status
        status:
          - 200
      - type: regex
        regex:
          - "Welcome, (.+?)!"
        condition: and
    extractors:
      - type: regex
        regex:
          - "Welcome, ([a-zA-Z0-9]+)!"
```

In this example, the payload `test-param` is iterated over, a GET request is sent that includes the payload value in the URL, headers and timeout are configured, and matchers are applied to validate both the status code and a pattern in the response. Additionally, an extractor is used to capture relevant information.

---

# Practical Guide: Vulnerable Server and Nuclei Template

Below is a step-by-step practical guide that includes:

1. **An HTML file** to launch a server.
2. **A custom Python script** to serve that HTML and return a specific header.
3. **A Nuclei template** that checks for the presence of that header.
4. **Instructions** to run the server and then use Nuclei to detect the vulnerability.

---

## 1. Create the HTML File

Create a file called `index.html` with the following content:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Vulnerable Page</title>
</head>
<body>
  <h1>Welcome to the Vulnerable Page</h1>
  <p>This is an example to demonstrate header vulnerability detection.</p>
</body>
</html>
```

This file will represent the static content served by our server.

---

## 2. Simulate a Vulnerable HTTP Server in Python

The standard Python server (`python3 -m http.server`) does not allow you to modify headers directly, so we will create a small script that inherits from `SimpleHTTPRequestHandler` and adds an extra header.

Create a file called `server.py` with the following content:

```python
import http.server
import socketserver

class CustomHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        # Add a custom header "vulnerable-header"
        self.send_header("vulnerable-header", "True")
        super().end_headers()

PORT = 8000

with socketserver.TCPServer(("", PORT), CustomHandler) as httpd:
    print(f"Server running on port {PORT}")
    httpd.serve_forever()
```

This script launches a server on port 8000 and, before completing each response, adds the header `vulnerable-header` with the value `True`.

---

## 3. Run the Server

Open a terminal in the directory containing `index.html` and `server.py`, and run:

```bash
python3 server.py
```

You will see a message in the terminal indicating that the server is running on port 8000. Now, if you visit `http://localhost:8000` in your browser, the server will serve the `index.html` file and, in the HTTP response, the header `vulnerable-header: True` will be included.

---

## 4. Create a Nuclei Template to Detect the Vulnerable Header

Create a file called `vulnerable-header.yaml` with the following content:

```yaml
id: vulnerable-header-check
info:
  name: "Vulnerable Header Detection"
  author: "YourName"
  severity: "low"
  description: "This template checks if the HTTP response contains the header 'vulnerable-header' with the value 'True'."
  tags: ["http", "header", "vulnerable"]

requests:
  - method: GET
    path:
      - "{{BaseURL}}"
    matchers:
      - type: word
        part: header
        words:
          - "vulnerable-header: True"
```

### Template Explanation:
- **id, info, and tags:** Metadata that helps identify and categorize the template.
- **requests:** A GET request is made to the target (`{{BaseURL}}` is replaced with the URL you specify when running Nuclei).
- **matchers:** A matcher is defined that looks for the string `vulnerable-header: True` in the headers. If found, the template will mark the target as vulnerable.

---

## 5. Run Nuclei with the Template

With the server running at `http://localhost:8000`, open another terminal and run:

```bash
nuclei -u http://localhost:8000 -t vulnerable-header.yaml
```

Nuclei will send a request to the server and, upon finding the header `vulnerable-header: True`, will display a result indicating that the test was successful.

---

# Conclusion

Nuclei templates offer tremendous flexibility and power, allowing you to:

- Document and categorize your tests using metadata.
- Define complex requests with different methods, paths, headers, and bodies.
- Use variables and payloads to automate tests and cover multiple scenarios.
- Apply matchers and extractors to validate precise conditions and extract valuable information.
- Configure advanced workflows with multiple steps, scripts, and conditions without modifying the tool's base code.

---