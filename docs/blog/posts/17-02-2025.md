---
title: "Introduction to Nuclei Templates"
summary: "Basic explanation of Nuclei templates with example"
date: 2025-02-17
tag:
    - Cybersecurity
    - Pentesting
    - Nuclei
    - Automation
    - Template
---

## How Nuclei Templates Work

In this article, we explore how **Nuclei** templates work, detailing the **process of creating and configuring custom vulnerability tests**. You'll learn the fundamentals. From setting up the basic information and crafting precise HTTP requests to using **variables**, **payloads**, **matchers** and **extractors** for dynamic testing. Additionally, a simple practical example to shows how to simulate a vulnerable server and detect a vulnerability using a custom **Nuclei** template.

<!-- more -->

---

## What is a Nuclei Template?

A Nuclei template is a YAML-formatted file that filling the following sections, allow you to standardize and automate vulnerability detection without having to rewrite code each time.

- **Basic Information:** Identifier, name, author, severity, and description.
- **Requests:** Configuration of the HTTP request (or any protocol) that will be sent to the target.
- **Matchers:** Conditions that must be met in the response to determine if the vulnerability is present.
- **Extractors (Optional):** Tools to extract additional information from the response.

---

## Explanation of the template parts 

### 1. Information Section (info)

This section is used to document and categorize the template filling these fields:

- **id:** A unique identifier for the template.
- **name:** The name of the template.
- **author:** The author or authors responsible for the template.
- **severity:** The criticality of the vulnerability (e.g., low, medium, high, critical).
- **description:** A description of what the template does and which vulnerability it detects.
- **reference:** Links to documentation, CVEs, or external resources that support the vulnerability.
- **tags:** Labels that facilitate the search and categorization of the template.

*Example:*

```yaml
info:
  id: example-vulnerability-id
  name: "Example of Generic Vulnerability"
  author: "AuthorName"
  severity: "medium"
  description: "This template detects a generic vulnerability in a web application."
  reference:
    - "https://example.com/vulnerability-details"
  tags: ["example", "web", "vulnerability"]
```

---

### 2. Request Definition

The core of a template is the definition of the requests that will be sent to the target by configuring:

- **method:** The HTTP method (GET, POST, PUT, DELETE, etc.) or the corresponding method for other protocols.
- **path:** The path or paths where the requests will be sent. You can use variables (such as `{{BaseURL}}`) to dynamically set the endpoint.
- **headers:** Allows you to define custom HTTP headers. This is useful to simulate different types of clients, manage cookies, or authenticate the request.
- **body:** The content of the request (for POST or PUT methods). You can define the body in different formats (JSON, XML, form data, etc.).
- **timeout and retries:** Options to configure the timeout and the number of retries in case a response is not received.

*Example:*

```yaml
requests:
  - method: POST
    path:
      - "{{BaseURL}}/api/login"
    headers:
      Content-Type: "application/json"
      User-Agent: "Mozilla/5.0 (compatible; Nuclei)"
    body: '{"username": "admin", "password": "admin"}'
    timeout: 5
    retries: 2
```

---

### 3. Use of Variables and Placeholders

Nuclei allows the use of variables in your templates to enhance flexibility and reusability, enabling you to create more dynamic templates that adapt to different scenarios without the need to edit the code each time.

- **Predefined variables:** Such as `{{BaseURL}}`, which is automatically replaced by the target.
- **Custom variables:** You can define your own variables within the template to reuse values in multiple sections such as URLs, tokens, or parts of the request body.

---

### 4. Payloads

*Payloads* are one of the most powerful features of Nuclei for conducting injection tests or brute-force attacks on parameters. They allow you to define lists of values, such as different strings, special characters, or specific patterns to test within a parameter. Once defined, Nuclei iterates over each value, executing a request for every payload, making it possible to cover a wide range of scenarios within a single template.

*Example:*

```yaml
payloads:
  usernames:
    - admin
    - root
    - test
```

Then, in the body or the URL, you can reference the payload with the syntax `{{payload}}` or `{{username}}` if you define it with a specific name like in the example.

---

### 5. Matchers

Matchers are essential for determining whether the server's response indicates the presence of a vulnerability. Nuclei offers several options:

- **Status Matcher:** Checks that the response has a specific HTTP status code (e.g., 200, 404).
- **Word Matcher:** Searches for specific strings in the response body.
- **Regex Matcher:** Uses regular expressions to search for complex patterns.
- **Size Matcher:** Validates that the content size is within an expected range.
- **Header Matcher:** Allows you to evaluate if certain headers are present or have a specific value.
- **JSON Matcher:** it allows you to validate specific keys and values in JSON responses.

The *matchers* can be combined and use the `condition` option to determine whether all (AND) or at least one (OR) must be met.

*Example:*

```yaml
matchers:
  - type: status
    status:
      - 200
  - type: word
    words:
      - "vulnerable-string"
    condition: and
```

---

### 6. Extractors

Extractors are tools to extract specific information from the response, which is very useful providing more information to vulnerability reports or chaining results across multiple steps. Some options are:

- **Regex Extractor:** Extracts data using regular expressions.
- **JSON Extractor:** Extracts values from specific keys in JSON responses.
- **HTML Extractor:** Can extract information from HTML documents (for example, titles, meta tags).

*Example:*

```yaml
extractors:
  - type: regex
    regex:
      - "user: ([a-zA-Z0-9]+)"
```

This extractor will search for patterns matching `user: something` and extract the value, which can be used to identify usernames or tokens in the response.

---

### 7. Advanced Features and Additional Options

#### Multiple Requests and Sequential Steps

- **Multi-step workflows:** You can chain multiple requests within a single template. This is useful when you need to perform a preliminary step (such as authentication) before executing the main check.
- **Conditional requests:** Requests can be conditioned based on previous results, allowing for more complex workflows.

#### Including Custom Scripts

- **Inline scripts:** Some templates allow you to include scripts (for example, in JavaScript or another compatible language) to perform checks or transform the response beyond basic matchers.
- **Operators and functions:** You can apply functions or manipulations to the extracted values to compare or transform them according to the test logic.

#### Connection Settings

- **Redirections:** Configure redirection handling, such as defining a maximum number of redirections or following them automatically.
- **Certificates and SSL:** Options to validate SSL certificates or ignore warnings in testing environments.

#### Customization with Environment Variables

- **External variables:** You can integrate variables defined in your environment (for example, via the command line) to further parameterize the template. This is especially useful in CI/CD pipelines.

---

### 8. Complete Example of an Advanced Template

As a summary, this example integrates several of the exposed possibilities: the payload test-param is iterated over, a GET request is sent with the payload value in the URL, headers and timeout are configured, matchers validate both the status code and a pattern in the response, and an extractor captures relevant information.

```yaml
id: big-example
info:
  name: "big Template Example"
  author: "authorName"
  severity: "high"
  description: "This template executes a multi-step workflow with payloads and extractors."
  reference:
    - "https://example.com/big-vulnerability"

payloads:
  test-param:
    - "admin"
    - "root"
    - "test"

requests:
  - method: GET
    path:
      - "{{BaseURL}}/api/data?user={{test-param}}"
    headers:
      User-Agent: "Nuclei-Attack"
    timeout: 10
    matchers:
      - type: status
        status:
          - 200
      - type: regex
        regex:
          - "Welcome, (.+?)!"
        condition: and
    extractors:
      - type: regex
        regex:
          - "Welcome, ([a-zA-Z0-9]+)!"
```

---

## Practical Guide: Vulnerable Server and Nuclei Template

Below is a step-by-step practical guide that includes:

1. **An HTML file** to launch a server.
2. **A custom Python script** to serve that HTML and return a specific "*vulnerable*" header.
3. **A Nuclei template** that checks for the presence of that header.
4. **Instructions** to run the server and then use Nuclei to detect the vulnerability.

---

### 1. Create the HTML File

Create a file called `index.html` with the following content:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Vulnerable Page</title>
</head>
<body>
  <h1>Welcome to the Vulnerable Page</h1>
  <p>This is an example to demonstrate header vulnerability detection.</p>
</body>
</html>
```

This file will represent the static content served by our server.

---

### 2. Simulate a Vulnerable HTTP Server in Python

To serve an HTML file while adding a custom header, we can create a small script that inherits from `SimpleHTTPRequestHandler` and modifies the response headers.

Create a file called `server.py` with the following content:

```python
import http.server
import socketserver

class CustomHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        # Add a custom header "vulnerable-header"
        self.send_header("vulnerable-header", "True")
        super().end_headers()

PORT = 8000

with socketserver.TCPServer(("", PORT), CustomHandler) as httpd:
    print(f"Server running on port {PORT}")
    httpd.serve_forever()
```

This script starts a server on port 8000 and, before completing each response, appends the `vulnerable-header` with the value `True`.

---

### 3. Run the Server

Open a terminal in the directory containing `index.html` and `server.py`, and run:

```bash
python3 server.py
```

You will see a message in the terminal indicating that the server is running on port 8000. Now, if you visit `http://localhost:8000` in your browser, the server will serve the `index.html` file and, in the HTTP response, the header `vulnerable-header: True` will be included.

---

### 4. Create a Nuclei Template to Detect the Vulnerable Header

Create a file called `vulnerable-header.yaml` with the following content:

```yaml
id: vulnerable-header-check
info:
  name: "Vulnerable Header Detection"
  author: "AuthorName"
  severity: "low"
  description: "This template checks if the HTTP response contains the header 'vulnerable-header' with the value 'True'."
  tags: ["http", "header", "vulnerable"]

requests:
  - method: GET
    path:
      - "{{BaseURL}}"
    matchers:
      - type: word
        part: header
        words:
          - "vulnerable-header: True"
```

#### Template Explanation:
- **id, info, and tags:** Metadata that helps identify and categorize the template.
- **requests:** A GET request is made to the target (`{{BaseURL}}` is replaced with the URL you specify when running Nuclei).
- **matchers:** A matcher is defined that looks for the string `vulnerable-header: True` in the headers. If found, the template will mark the target as vulnerable.

---

### 5. Run Nuclei with the Template

With the server running at `http://localhost:8000`, open another terminal and run:

```bash
nuclei -u http://localhost:8000 -t vulnerable-header.yaml
```

Nuclei will send a request to the server and, upon finding the header `vulnerable-header: True`, will display a result indicating that the test was successful.

---

## Conclusion

Nuclei templates offer tremendous flexibility and power, allowing you to:

- Document and categorize your tests using metadata.
- Define complex requests with different methods, paths, headers, and bodies.
- Use variables and payloads to automate tests and cover multiple scenarios.
- Apply matchers and extractors to validate precise conditions and extract valuable information.
- Configure advanced workflows with multiple steps, scripts, and conditions without modifying the tool's base code.

---