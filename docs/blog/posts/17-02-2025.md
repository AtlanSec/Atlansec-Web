---
title: "Introduction to Nuclei Templates"
summary: "Basic explanation of Nuclei templates with example"
date: 2025-02-17
tag:
    - Cybersecurity
    - Pentesting
    - Nuclei
    - Automation
    - Template
---

## How Nuclei Templates Work

In this article, we explore how [**Nuclei**](https://docs.projectdiscovery.io/templates/introduction) templates work, detailing the **process of creating and configuring custom vulnerability tests**. You'll learn the fundamentals, from setting up the basic information and crafting precise HTTP requests to using **variables**, **payloads**, **matchers**, and **extractors** for dynamic testing. Additionally, a practical example demonstrates how to simulate a vulnerable server and detect a vulnerability using a custom **Nuclei** template.

---

## What is a Nuclei Template?

A Nuclei template is a YAML-formatted file that, by filling in specific sections, allows you to standardize and automate vulnerability detection without having to rewrite code each time.

- **Basic Information:** Identifier, name, author, severity, and description.
- **Requests:** Configuration of HTTP requests that will be sent to the target.
- **Matchers:** Conditions that must be met in the response to determine if the vulnerability is present.
- **Extractors (Optional):** Tools to extract additional information from the response.

---

## Explanation of the Template Parts

## 1. Information Section (info)

This section documents and categorizes the template with the following fields:

- **id:** A unique identifier for the template.
- **name:** The name of the template.
- **author:** The author or authors responsible for the template.
- **severity:** The criticality of the vulnerability (e.g., low, medium, high, critical).
- **description:** A description of what the template does and which vulnerability it detects.
- **reference:** Links to documentation, CVEs, or external resources that support the vulnerability.
- **tags:** Labels that facilitate the search and categorization of the template.

*Example:*

```yaml
info:
  id: example-vulnerability-id
  name: "Example of Generic Vulnerability"
  author: "AuthorName"
  severity: "medium"
  description: "This template detects a generic vulnerability in a web application."
  reference:
    - "https://example.com/vulnerability-details"
  tags: ["example", "web", "vulnerability"]
```

---

## 2. Request Definition

The core of a template is the definition of the HTTP requests that will be sent to the target. This section is exclusive to HTTP templates and includes:

- **method:** For the HTTP protocol a method (GET, POST, PUT, DELETE, etc.) can be defined.
- **path:** The paths where the requests will be sent. You can use variables (such as `{{BaseURL}}`) to dynamically set the endpoint.
- **headers:** Define custom HTTP headers to simulate different clients, manage cookies, or authenticate the request.
- **body:** The request content (for POST or PUT methods) in various formats (JSON, XML, form data, etc.).
- **timeout and retries:** Options to configure the timeout and number of retries in case a response is not received.

*Example:*

```yaml
requests:
  - method: POST
    path:
      - "{{BaseURL}}/api/login"
    headers:
      Content-Type: "application/json"
      User-Agent: "Mozilla/5.0 (compatible; Nuclei)"
    body: '{"username": "admin", "password": "admin"}'
    timeout: 5
    retries: 2
```

---

## 3. Use of Variables and Placeholders

Nuclei allows the use of variables in your templates to enhance flexibility and reusability, enabling you to create more dynamic templates that adapt to different scenarios without the need to edit the code each time. Some protocols do not support variables, so it's important to check compatibility.

- **Predefined variables:** Such as `{{BaseURL}}`, which is automatically replaced by the target.
- **Custom variables:** You can define your own variables to reuse values in multiple sections, such as URLs, tokens, or parts of the request body.
Currently *dns*, *http*, *headless* and *network* protocols support variables.
- **Functions:** Variables can also use functions to manipulate values dynamically, for example `base64_decode("YXRsYW5zZWMK")`.

---

## 4. Payloads

*Payloads* allow performing injection tests or brute-force attacks on parameters. Some protocols do not support payloads, and **attack modes**(e.g. batteringram, pitchfork and clusterbomb) can also be defined for more advanced exploitation techniques.

- Define lists of values such as strings, special characters, or patterns.
- Iterate over each value, executing a request for every payload to cover various scenarios.
- Combine payloads with functions to manipulate input dynamically.
- This section allows to use fuctions as the previous.

*Example:*

```yaml
payloads:
  usernames:
    - admin
    - root
    - test
```

These payloads can then be referenced in requests using `{{username}}`.

---

## 5. Matchers

*Matchers* provide a powerful and flexible way to compare parts of protocol responses. They allow for simple checks and can be combined to perform complex validations.

### Types of Matchers

There are **7 basic matcher types**, each targeting a specific part of a response:

- **status:**  
  Checks the HTTP response status code by comparing integer values (e.g., 200, 302).

- **size:**  
  Compares the content length of a response part to ensure it meets specified size criteria.

- **word:**  
  Searches for specific words or phrases within a designated part of the response.

- **regex:**  
  Uses regular expressions to match text patterns in the response, offering flexible pattern matching.

- **binary:**  
  Matches hexadecimal or binary sequences within a response, useful for detecting file signatures or binary data.

- **dsl:**  
  Employs a domain-specific language to create complex expressions, allowing the combination of multiple conditions (like body length, status code, etc.).

- **xpath:**  
  Applies XPath queries to XML or HTML responses to locate elements or text, which is ideal for structured document matching.

### Examples

#### Status Matcher
```yaml
matchers:
  - type: status
    status:
      - 200
      - 302
```

#### Binary Matcher
```yaml
matchers:
  - type: binary
    binary:
      - "504B0304"         # zip archive
      - "526172211A070100"   # RAR archive v5.0
      - "FD377A585A0000"     # xz tar.xz archive
    condition: or
    part: body
```

#### Hex-Encoded Word Matcher
```yaml
matchers:
  - type: word
    encoding: hex
    words:
      - "50494e47"
    part: body
```

#### XPath Matcher
```yaml
matchers:
  - type: xpath
    part: body
    xpath:
      - "/html/head/title[contains(text(), 'Example Domain')]"
```

#### DSL Matcher
```yaml
matchers:
  - type: dsl
    dsl:
      - "len(body)<1024 && status_code==200"    # Body length check and status code validation
      - "contains(toupper(body), md5(cookie))"    # MD5 check on cookies within body
```

> **Note:** DSL matchers can access various response parts such as `content_length`, `status_code`, `all_headers`, `body`, `header_name`, and `raw`.

### Conditions

- **AND:** All specified words/regex patterns must match.
- **OR:** At least one word/regex pattern must match.

Example using the **AND** condition:
```yaml
matchers:
  - type: word
    words:
      - "[core]"
      - "[config]"
    condition: and
    part: body
```

### Negative Matchers

Negative matchers exclude results that match specific criteria. This is enabled by setting `negative: true`.

Example:
```yaml
matchers:
  - type: word
    words:
      - "PHPSESSID"
    part: header
    negative: true
```

### Multiple and Internal Matchers

Multiple matchers can be used within a single template to validate several conditions simultaneously. The default operation between matchers is **OR**, but you can enforce an **AND** operation using `matchers-condition: and`.

Example with multiple matchers:
```yaml
matchers:
  - type: word
    name: php
    words:
      - "X-Powered-By: PHP"
      - "PHPSESSID"
    part: header
  - type: word
    name: node
    words:
      - "Server: NodeJS"
      - "X-Powered-By: nodejs"
    condition: or
    part: header
  - type: word
    name: python
    words:
      - "Python/2."
      - "Python/3."
    condition: or
    part: header
```

And with `matchers-condition: and`:
```yaml
matchers-condition: and
matchers:
  - type: word
    words:
      - "X-Powered-By: PHP"
      - "PHPSESSID"
    condition: or
    part: header
  - type: word
    words:
      - "PHP"
    part: body
```

#### Internal Matchers

When building multi-protocol or flow-based templates, you may use internal matchers (using `internal: true`) to perform pre-checks without outputting their results.

Example:
```yaml
id: CVE-2023-6553

info:
  name: Worpress Backup Migration <= 1.3.7 - Unauthenticated Remote Code Execution
  author: FLX
  severity: critical

flow: http(1) && http(2)

http:
  - method: GET
    path:
      - "{{BaseURL}}/wp-content/plugins/backup-backup/readme.txt"
    matchers:
      - type: dsl
        dsl:
          - 'status_code == 200'
          - 'contains(body, "Backup Migration")'
        condition: and
        internal: true  # This matcher is internal and won't print a result

  - method: POST
    path:
      - "{{BaseURL}}/wp-content/plugins/backup-backup/includes/backup-heart.php"
    headers:
      Content-Dir: "{{rand_text_alpha(10)}}"
    matchers:
      - type: dsl
        dsl:
          - 'len(body) == 0'
          - 'status_code == 200'
          - '!contains(body, "Incorrect parameters")'
        condition: and
```

This overview highlights the flexibility and extensive configurability of matchers in Nuclei, making it a robust tool for effective scanning and response validation.

---

## 6. Extractors

*Extractors* allow you to capture and display specific data from a response. They are especially useful for retrieving dynamic values (such as tokens, IDs, or header values) that can be reused in subsequent requests.

### Types of Extractors

- **regex:**  
  Uses regular expressions to extract patterns from a designated part of the response (e.g., body, header).  
  *Example:* Capture API keys or tokens by matching specific regex patterns.

- **kval:**  
  Extracts key-value formatted data from response headers or cookies.  
  *Note:* Replace dashes (`-`) with underscores (`_`) in key names (e.g., `content_type` instead of `content-type`).

- **json:**  
  Utilizes a JQ-like syntax to navigate and extract values from JSON responses.  
  *Example:* Extract an object's `id` field using a JSON path expression.

- **xpath:**  
  Uses XPath queries to extract data from HTML or XML responses.  
  *Example:* Extract the `href` attribute from an anchor tag or text from a specific element.

- **dsl:**  
  Applies DSL expressions to extract computed values from the response, such as evaluating the length of the response body.  
  *Example:* Use `len(body)` to capture the effective body length.

### Dynamic and Reusable Extractors

- **Dynamic Extractors:**  
  These capture values at runtime (e.g., CSRF tokens or session IDs) for use in multi-request templates. Mark them with `internal: true` to prevent printing extracted values.

- **Reusable Dynamic Extractors:**  
  Dynamic values extracted in one request can be immediately reused in subsequent extractors and requests, enhancing template flexibility and interactivity.

---

### Regex Extractor

Extracts data from the response body using a regular expression.

```yaml
extractors:
  - type: regex      # Type of the extractor
    part: body       # Part of the response (header, body, or all)
    regex:
      - "(A3T[A-Z0-9]|AKIA|AGPA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}"
```

---

### Kval Extractor

Extracts a value (e.g., content-type) from headers or cookies.

```yaml
extractors:
  - type: kval      # Type of the extractor
    kval:
      - content_type   # Note the underscore instead of dash
```

---

### JSON Extractor

Extracts a value from a JSON response using JQ-like syntax.

```yaml
extractors:
  - type: json       # Type of the extractor
    part: body
    name: user
    json:
      - '.[] | .id'   # JQ-like expression to extract the id value
```

---

### XPath Extractor

Extracts attribute values from HTML responses using XPath.

```yaml
extractors:
  - type: xpath      # Type of the extractor
    attribute: href  # Attribute to extract (optional)
    xpath:
      - '/html/body/div/p[2]/a'  # XPath for extraction
```

---

### DSL Extractor

Extracts data using a DSL expression, such as obtaining the length of the response body.

```yaml
extractors:
  - type: dsl       # Type of the extractor
    dsl:
      - len(body)   # DSL expression to extract effective body length
```

---

### Dynamic Extractors

Dynamic extractors capture values (e.g., CSRF tokens or session headers) at runtime for use in multi-request templates. To keep these values internal (not printed on the terminal), use `internal: true`.

**Example using a regex extractor to capture a dynamic value:**

```yaml
extractors:
  - type: regex
    name: api         # Variable name to store the extracted value
    part: body
    internal: true    # Marks the value as internal
    regex:
      - "(?m)[0-9]{3,10}\\.[0-9]+"
```

You can also specify a `group` option to capture specific submatches:

```yaml
extractors:
  - type: regex
    name: csrf_token  # Variable name
    part: body
    group: 1          # Captures the first submatch
    regex:
      - '<input\sname="csrf_token"\stype="hidden"\svalue="([[:alnum:]]{16})"\s/>'
```

*Without the `group` option, the extractor returns the full match instead of just the submatch.*

---

### Reusable Dynamic Extractors

With Nuclei v3.1.4 and later, dynamically extracted values (e.g., `csrf_token`) are immediately reusable in subsequent extractors and requests.

**Example:**

```yaml
id: basic-raw-example

info:
  name: Test RAW Template
  author: pdteam
  severity: info

http:
  - raw:
      - |
        GET / HTTP/1.1
        Host: {{Hostname}}

    extractors:
      - type: regex
        name: title      # Captures the title
        group: 1
        regex:
          - '<title>(.*)<\/title>'
        internal: true

      - type: dsl
        dsl:
          - '"Title is " + title'
```

In this example, the dynamic variable `title` captured from the regex extractor is reused in the DSL extractor for further processing.

---

## 7. Advanced Features

## Multiple Requests

Chaining multiple requests within a single template lets you simulate multi-step interactions. This is useful when one request's output (such as an extracted token or a session cookie) needs to be fed into subsequent requests. For instance, you might first perform a GET request to fetch a CSRF token and then use that token in a POST request to submit a form.

**Example:**

```yaml
requests:
  - method: GET
    path:
      - "{{BaseURL}}/login"
    extractors:
      - type: regex
        name: csrf_token
        part: body
        regex:
          - 'name="csrf_token" value="([^"]+)"'
  - method: POST
    path:
      - "{{BaseURL}}/submit"
    headers:
      Content-Type: application/x-www-form-urlencoded
    body: "username=admin&password=admin&csrf_token={{csrf_token}}"
```

In this example, the first request extracts the `csrf_token` from the login page, and the second request uses that token to authenticate the user.

---

## Custom Scripts

Custom scripts allow inline processing of extracted values or payloads, enabling you to manipulate data on the fly before sending a request. This is particularly useful when you need to modify an extracted value (such as converting its case, applying encryption, or performing any custom transformation) prior to its subsequent usage.

**Example:**

```yaml
requests:
  - method: GET
    path:
      - "{{BaseURL}}/data"
    extractors:
      - type: regex
        name: token
        part: body
        regex:
          - 'token: "([A-Za-z0-9]+)"'
  - method: POST
    path:
      - "{{BaseURL}}/submit"
    body: |
      {
        "modifiedToken": "{{= token.toLowerCase() }}"
      }
```

Here, after extracting the `token`, an inline script (`{{= token.toLowerCase() }}`) is applied to convert it to lowercase before it is inserted into the JSON payload of the POST request.

---

## Attack Modes

Attack modes define how payloads are injected into requests. They determine whether a single payload is used across all injection points or if multiple payloads are combined in different ways. Nuclei supports several attack modes, each tailored for specific testing strategies:

- **Battering Ram:** Uses the same payload for every injection point in a request.
- **Clusterbomb:** Combines multiple payloads in every possible way across different injection points.
- **Pitchfork:** Injects payloads synchronously across multiple injection points.

**Example:**

```yaml
requests:
  - method: GET
    path:
      - "{{BaseURL}}/api/data?user={{test-param}}"
    attack: "battering-ram"
```

In this example, the `battering-ram` attack mode is used. This means that every payload is directly injected into the `{{test-param}}` placeholder. Depending on your testing scenario, you might choose a different attack mode to explore various combinations of payload injections.

---

## Practical Guide: Vulnerable Server and Nuclei Template

Below is a step-by-step practical guide that includes:

1. **An HTML file** to launch a server.
2. **A custom Python script** to serve that HTML and return a specific "*vulnerable*" header.
3. **A Nuclei template** that checks for the presence of that header.
4. **Instructions** to run the server and then use Nuclei to detect the vulnerability.

---

## 1. Create the HTML File

Create a file called `index.html` with the following content:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Vulnerable Page</title>
</head>
<body>
  <h1>Welcome to the Vulnerable Page</h1>
  <p>This is an example to demonstrate header vulnerability detection.</p>
</body>
</html>
```

This file will represent the static content served by our server.

---

## 2. Simulate a Vulnerable HTTP Server in Python

To serve an HTML file while adding a custom header, we can create a small script that inherits from `SimpleHTTPRequestHandler` and modifies the response headers.

Create a file called `server.py` with the following content:

```python
import http.server
import socketserver

class CustomHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        # Add a custom header "vulnerable-header"
        self.send_header("vulnerable-header", "True")
        super().end_headers()

PORT = 8000

with socketserver.TCPServer(("", PORT), CustomHandler) as httpd:
    print(f"Server running on port {PORT}")
    httpd.serve_forever()
```

This script starts a server on port 8000 and, before completing each response, appends the `vulnerable-header` with the value `True`.

---

## 3. Run the Server

Open a terminal in the directory containing `index.html` and `server.py`, and run:

```bash
python3 server.py
```

You will see a message in the terminal indicating that the server is running on port 8000. Now, if you visit `http://localhost:8000` in your browser, the server will serve the `index.html` file and, in the HTTP response, the header `vulnerable-header: True` will be included.

---

## 4. Create a Nuclei Template to Detect the Vulnerable Header

Create a file called `vulnerable-header.yaml` with the following content:

```yaml
id: vulnerable-header-check
info:
  name: "Vulnerable Header Detection"
  author: "AuthorName"
  severity: "low"
  description: "This template checks if the HTTP response contains the header 'vulnerable-header' with the value 'True'."
  tags: ["http", "header", "vulnerable"]

requests:
  - method: GET
    path:
      - "{{BaseURL}}"
    matchers:
      - type: word
        part: header
        words:
          - "vulnerable-header: True"
```

### Template Explanation:
- **id, info, and tags:** Metadata that helps identify and categorize the template.
- **requests:** A GET request is made to the target (`{{BaseURL}}` is replaced with the URL you specify when running Nuclei).
- **matchers:** A matcher is defined that looks for the string `vulnerable-header: True` in the headers. If found, the template will mark the target as vulnerable.

---

## 5. Run Nuclei with the Template

With the server running at `http://localhost:8000`, open another terminal and run:

```bash
nuclei -u http://localhost:8000 -t vulnerable-header.yaml
```

Nuclei will send a request to the server and, upon finding the header `vulnerable-header: True`, will display a result indicating that the test was successful.


## Conclusion

Nuclei templates provide a flexible and powerful way to automate security testing. By leveraging variables, payloads, matchers, extractors, and attack modes, you can create dynamic and reusable tests tailored to your needs.

---