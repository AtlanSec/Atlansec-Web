---
title: "Server-Side Request Forgery: The Backdoor That Can Bring Down Your Infrastructure"
summary: "In today's complex cybersecurity landscape, where web application security is crucial, few vulnerabilities are as insidious and potentially devastating as **Server-Side Request Forgery (SSRF)**. This attack technique, often underestimated, can turn an apparently secure server into a gateway for cybercriminals, allowing them to access internal resources, steal sensitive data, and even launch attacks against third parties.\n\nThe result? Data theft, access to internal services, remote code execution, and ultimately, reputational damage, fines for non-compliance with regulations like GDPR, and significant financial losses. A successful SSRF attack can cripple critical operations and compromise customer trust."
date: 2025-03-23
tag:
  - Cybersecurity
  - Pentesting
  - SSRF
  - Web Security
  - Vulnerabilities
lang: en
---

# Server-Side Request Forgery: The Backdoor That Can Bring Down Your Infrastructure

In today's complex cybersecurity landscape, where web application security is crucial, few vulnerabilities are as insidious and potentially devastating as **Server-Side Request Forgery (SSRF)**. This attack technique, often underestimated, can turn an apparently secure server into a gateway for cybercriminals, allowing them to access internal resources, steal sensitive data, and even launch attacks against third parties.

The result? Data theft, access to internal services, remote code execution, and ultimately, reputational damage, fines for non-compliance with regulations like GDPR, and significant financial losses. A successful SSRF attack can cripple critical operations and compromise customer trust.

<!-- more -->

## What is SSRF?

Server-Side Request Forgery (SSRF) attacks occur when an attacker manipulates a server to perform unauthorized HTTP requests. Imagine a web server as a messenger. Normally, it delivers messages (requests) only to authorized recipients. An SSRF occurs when an attacker tricks the server into delivering messages to unauthorized recipients within the internal network, such as databases or management servers.

For example, consider a shopping application that allows users to check product availability. To provide stock information, the application queries several backend REST APIs by passing the URL to the API endpoint via an HTTP request. An attacker could change the URL to something like `http://localhost/admin` to access the server's admin interface.

## Impact of SSRF Attacks

According to [PortSwigger](https://portswigger.net/web-security/ssrf#what-is-the-impact-of-ssrf-attacks){:target="_blank"}, the impact of SSRF attacks can result in unauthorized access to internal server resources. In some cases, SSRF vulnerabilities could allow an attacker to execute arbitrary commands. An SSRF exploit that causes connections to third-party external systems could result in malicious forward attacks. These may appear to originate from the organization hosting the vulnerable application. For example, an attacker could use a server vulnerable to SSRF to scan ports on another company's internal network or even launch a DoS attack against an external service, making it seem as though the attack originated from the organization hosting the vulnerable application.

## Types of Server-Side Request Forgery

There are three main types of SSRF attacks:

- **Standard SSRF**: In this type of attack, the server's response is directly shown to the attacker. The server fetches the URL requested by the attacker and sends the response back.
- **Blind SSRF**: In this case, the response is not sent back to the attacker. The attacker must devise ways to confirm the vulnerability without directly seeing the server's response.
- **Time-Based Blind SSRF**: A variant of blind SSRF where the attacker infers information based on the time it takes for the server to respond. This type of attack targets specific scenarios and will not be the focus of this post.

Next, we will explore the characteristics and exploitation methods of each type of SSRF. These require different approaches for detecting and mitigating these vulnerabilities.

### **Standard SSRF**

The standard SSRF attack is the most straightforward form of this attack. In this scenario, the attacker can directly observe the server's response to the manipulated request. This allows the attacker to gather detailed information about the internal network, identify accessible services, and potentially retrieve sensitive data. An attacker could use this type of SSRF to read sensitive configuration files on the server (e.g., `file:///etc/passwd` on Linux).

Consider a web application that allows users to check product stock by querying an internal API.

#### Exploitation Methodology

The exploitation of this type of SSRF can be divided into three phases:

1.  **Injection:** The attacker introduces a malicious URL into an input field of the application.
2.  **Request:** The server, without validating the URL, makes a request to the resource specified by the attacker.
3.  **Disclosure:** The server's response is returned to the attacker, allowing access to internal information or unauthorized actions.

For example, a web application allows users to check product stock by querying an internal API:

Using a tool like Burp Suite, we can observe the request made to check product stock:

```http
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://internal-stock-api/check?productId=123
```

This request retrieves the stock status of a product identified by `productId`.

However, an attacker could modify the request to point to a different URL, such as:

```http
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin
```

If the `/admin` directory is hosted locally and the request is processed without proper validation, the attacker could access the local admin panel, exposing sensitive information or restricted functionalities. This type of attack is referred to as a '_server-side SSRF attack_'.

**Possible Response (if access is successful):**

```http
HTTP/1.1 200 OK
Content-Type: text/plain

admin:password123
user1:password456
```

### **Blind SSRF**

Blind SSRF attacks are more challenging for attackers because they do not directly receive the server's response. Instead, attackers must infer the success of their intrusion through observable changes in the application's behavior. An attacker could use this type of SSRF to trigger internal functions that are not normally exposed to the public.

#### Exploitation Methodology

Imagine a web application that allows users to upload profile pictures. The application validates the image by making a request to the provided URL but does not display the result of this validation to the user.

```python
import requests

def verify_image(url):
  try:
    response = requests.get(url, timeout=5)
    if response.headers.get('content-type', '').startswith('image/'):
      return True
  except:
    pass
    return False

user_provided_url = "https://example.com/image.jpg"
if verify_image(user_provided_url):
  print("Valid image")
else:
  print("Rejected URL")
```

Here, the server receives a URL provided by a user, such as `https://example.com/image.jpg`, and performs an HTTP request to verify if it contains an image. If the URL points to a resource with the header **Content-Type: image/\***, it is considered valid.

The problem lies in the **server blindly trusting** URLs provided by users, allowing arbitrary HTTP requests.

If an attacker provides a URL pointing to an internal server resource, such as `http://internal-server/sensitive-data`, they won't see the server's response directly but can observe certain behaviors to deduce whether the request was successful:

- **Response Time**: If the internal resource takes longer to respond (e.g., due to being a heavy service), it may indicate that the server accessed the resource.
- **Error Messages**: If the server returns different errors depending on whether it could access the resource, this can be exploited to confirm its existence.

To verify whether the attacker's request from the server to their target was successful, **out-of-band (OOB)** techniques are used, such as:
`http://internal-server.sensitive-data.attacker-domain.com`. In this malicious URL, `attacker-domain` is controlled by the attacker. The vulnerable server will attempt to resolve this malicious domain and make an HTTP request to it. As a result, the attacker can monitor their DNS or web server to confirm the request. Services like [Canarytokens](https://canarytokens.org/generate){:target="_blank"} can also be used to generate unique tokens that alert when accessed.

## How to Prevent SSRF Attacks

As demonstrated, these attacks are particularly dangerous, facilitating the exploitation of internal or external server resources. To protect against this vulnerability, it is essential to implement a combination of robust security measures. Below are the most effective strategies:

### **Strict Input Validation**

To protect against standard SSRF attacks, consider:

- **Whitelists**: Allow the server to access only specific, trusted URLs necessary for the application's functionality. Define a whitelist of domains and paths the server can access. Any request not matching this whitelist should be rejected. Example: `allowed = ["api.example.com/products", "images.example.com"]`.
- **Block Internal Addresses**: Block requests to internal URLs to prevent access to internal server resources (`localhost` or any IP like `192.168.x.x`). Configure the server to reject requests to private IP addresses (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) and `localhost` (127.0.0.1).
- **Restrict Protocols**: Block protocols like **ftp://**, **file://**, among others.

### **Use Web Application Firewalls (WAFs)**

Configure a WAF with specific rules to detect and block suspicious patterns related to SSRF. WAFs can act as an additional defense layer by monitoring and filtering outgoing server traffic. Example WAF rules:

- Block any request containing `127.0.0.1` or `localhost` in the URL.
- Block requests using protocols like `file://`, `ftp://`, `gopher://`.
- Block requests to private IP addresses.

### **Updates and Patches**

Ensure all server components (OS, web server, frameworks, libraries) are updated with the latest security patches. Updates often fix known SSRF vulnerabilities.

### **Network Segmentation**

Divide the network into segments and limit access between them. For example, the web server should not have direct access to the database. Instead, it should communicate through an intermediary service with limited permissions.

### **Regular Security Testing**

Conduct regular tests to identify potential SSRF vulnerabilities in your application before they can be exploited:

- Analyze all inputs that may generate HTTP requests.
- Test with different types of URLs (internal, external, malicious) to identify weaknesses.

### **Out-of-Band (OOB) Techniques**

Although blind SSRF does not show responses directly to the attacker, OOB techniques can help detect malicious attempts:

- Configure tools like a controlled DNS server to identify unexpected requests to external domains.
- Monitor interactions with external servers controlled by the attacker.

## Conclusion

Preventing SSRF attacks requires a layered security approach, combining input validation, WAFs, regular updates, network segmentation, and security testing. By implementing these measures, you can significantly reduce the risk of your infrastructure being compromised by this dangerous vulnerability. Remember, security is an ongoing process, and staying updated on the latest vulnerabilities and attack techniques is crucial.

**Disclaimer:** The information provided in this document is for educational purposes only. It should not be used for illegal or unauthorized activities.

---