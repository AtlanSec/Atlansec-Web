---
title: "Server-Side Request Forgery: The Backdoor That Can Bring Down Your Infrastructure"
summary: "In the realm of web security, **Server-Side Request Forgery (SSRF)** vulnerabilities stand out as one of the most critical and underestimated threats. They allow attackers to manipulate servers to make unauthorized HTTP requests to internal systems, compromising everything from APIs and cloud services to firewall-protected infrastructures.\n\nThis often-underestimated attack technique can transform an apparently secure server into a gateway for cybercriminals, allowing them to access internal resources, steal sensitive data, and even launch attacks against third parties.\n\nThe result? Data theft, access to internal services, remote code execution, and ultimately, damage to reputation, fines for non-compliance with regulations like GDPR, and significant financial losses. A successful SSRF attack can paralyze critical operations and compromise customer trust."
date: 2025-03-23
tags:
  - Cybersecurity
  - Pentesting
  - SSRF
  - Web Security
  - Vulnerabilities
lang: en
---

# Server-Side Request Forgery: The Backdoor That Can Bring Down Your Infrastructure

In the realm of web security, **Server-Side Request Forgery (SSRF)** vulnerabilities stand out as one of the most critical and underestimated threats. They allow attackers to manipulate servers to make unauthorized HTTP requests to internal systems, compromising everything from APIs and cloud services to firewall-protected infrastructures.

This often-underestimated attack technique can transform an apparently secure server into a gateway for cybercriminals, allowing them to access internal resources, steal sensitive data, and even launch attacks against third parties.

The result? Data theft, access to internal services, remote code execution, and ultimately, damage to reputation, fines for non-compliance with regulations like GDPR, and significant financial losses. A successful SSRF attack can paralyze critical operations and compromise customer trust.

<!-- more -->

## What is SSRF?

Server-Side Request Forgery (SSRF) attacks occur when an attacker can manipulate a server to make unauthorized HTTP requests. Imagine a web server is like a messenger. Normally, it only delivers messages (requests) to authorized recipients. An SSRF occurs when an attacker tricks the server into delivering messages to unauthorized recipients within the internal network, such as databases or management servers.

For example, we have a shopping application that allows users to see if a product is in stock. To provide stock information, the application makes queries to various back-end REST APIs. It does this by passing the URL to the API endpoint through an HTTP request. An attacker could change the URL to access other internal API endpoints and, for example, list other users.

In addition, SSRF attacks are not limited to the HTTP protocol only. In some cases, an attacker might try to use other URI schemes, such as `file://`, to access local files on the server. For example, if the server does not properly validate the provided URLs, an attacker could try to access a sensitive file on Linux systems. Although the `file://` scheme is not always enabled, it is still a potential attack vector that should be considered when implementing security measures.

## Impact of SSRF Attacks

According to [PortSwigger](https://portswigger.net/web-security/ssrf#what-is-the-impact-of-ssrf-attacks){:target="_blank"}, the impact of SSRF attacks can result in unauthorized access to internal server resources. Additionally, in some situations, the SSRF vulnerability could allow an attacker to execute arbitrary commands.

An SSRF exploit that causes connections to external third-party systems could result in malicious forward attacks. These may appear to originate from the organization hosting the vulnerable application. For example, an attacker could use an SSRF-vulnerable server to scan ports on another company's internal network or even to launch a DoS attack against an external service, making it appear that the attack is coming from the organization hosting the vulnerable application.

In the context of an intranet scan, an attacker could leverage an SSRF to send requests to internal IP addresses of the target network from the compromised server. This would allow mapping internal services, identifying open ports, and collecting information about the internal infrastructure, all while hiding behind the vulnerable server. This type of attack can be particularly damaging if the compromised server has privileged access to internal resources that would normally be protected from external access.

## Types of Server-Side Request Forgery

There are two main types of Server-Side Request Forgery (SSRF) attacks:

-   **Standard SSRF**: In this type of attack, the server's response is shown directly to the attacker. The server gets the URL requested by the attacker and sends the response back.
-   **Blind SSRF**: In this case, the response is not sent back to the attacker. The attacker must devise ways to confirm the vulnerability without directly seeing the server's response.

Next, we will see the characteristics and exploitation methods of each type of SSRF. This requires different approaches to the detection and mitigation of these vulnerabilities.

### **Standard SSRF**

The standard SSRF attack is the most direct way to perform this attack. In this scenario, the attacker can directly observe the server's response to the manipulated request. This allows the attacker to collect detailed information about the internal network, identify accessible services, and potentially retrieve sensitive data. An attacker could use this type of SSRF to access internal server resources, such as configuration files or locally stored data, that would normally not be exposed to the public.

One thing to keep in mind is that the `/etc/passwd` file is not particularly sensitive; it is used in PoCs because it always exists, but ultimately the goal is to be able to access unauthorized internal resources.

#### Exploitation Methodology

Exploitation of this type of SSRF is divided into 3 phases:

1.  **Injection:** The attacker introduces a malicious URL into an application input field.
2.  **Request:** The server, without validating the URL, makes a request to the resource specified by the attacker.
3.  **Revelation:** The server's response is returned to the attacker, allowing them to access internal information or perform unauthorized actions.

In the following example, we have a web application that allows you to check the stock of the products it offers:

Using an application proxy such as the Burpsuite tool, we can see the request that is made when viewing the stock of products:

```http
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=stockApi=http://internal-stock-api/check?productId=123
```

This request causes the client to receive the stock status of a product indicated with the `productId`.

However, the attacker could modify the request to the URL that is specified, such as:

```http
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin
```

By modifying the request, if the `/admin` directory exists on the local machine and this request is processed without proper validation, the local administration panel could be accessed, exposing sensitive information or restricted functionalities.

#### Example of accessing Amazon EC2 metadata:

An attacker might try to access the metadata of an EC2 instance:
```http
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://169.254.169.254/latest/meta-data/
```

This could expose critical system information, such as password hashes.

You can read more [here](https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service/){:target="_blank"} about how to protect metadata in Amazon EC2.

### **Blind SSRF**

The Blind SSRF attack represents a greater challenge for attackers, as they do not directly receive the server's response. In this type of attack, cybercriminals must infer the success of their intrusion through observable changes in the application's behavior. An attacker could use this type of SSRF to activate internal functions that are not normally exposed to the public.

#### Exploitation Methodology

Let's imagine a web application that allows users to upload profile pictures. The application verifies that the image is valid by making a request to the provided URL, but it does not show the result of this verification to the user.

```python
import requests
def verify_image(url):
  try:
    response = requests.get(url, timeout=5)
    if response.headers.get('content-type', '').startswith('image/'):
      return True
  except:
    pass
    return False

  user_provided_url = "https://example.com/image.jpg"
  if verify_image(user_provided_url):
    print("Valid image")
  else:
    print("Rejected URL")
```


As we can see, the server receives a URL provided by a user, in this case it is `https://example.com/image.jpg`, then makes an HTTP request to that URL to verify if it contains an image. And finally, if the provided URL accesses a resource, in this case with the header **Content-Type: image/\*** it will be considered valid.

The problem lies in the fact that the **server blindly trusts** the URLs that are provided by the users, thus allowing arbitrary *HTTP* requests to be made.

Therefore, if an attacker provides a URL which is controlled by themselves or that simply points to an internal resource of the server itself, for example `http://internal-server/sensitive-data`, the attacker will not directly see the server's response, but will be able to observe certain behaviors to deduce whether the request was successful or not:

-   **Response time**: If the internal resource takes longer to respond (for example, because it is a heavy service), this could indicate that the server accessed the resource.
-   **Error messages**: If the server returns different errors depending on whether it was able to access the resource or not, this can be exploited to confirm the existence of the resource.

For example, if the resource accessed by the attacker does not exist, the server's response will be shorter compared to if the resource exists.

In order to verify if the request that the attacker has made from the server to its target is correct, **out-of-band (OOB)** techniques are used, for example:
`http://internal-server.sensitive-data.attacker-domain.com`. As we can see in this malicious URL, `attacker-domain` is a domain controlled by the attacker, therefore, the vulnerable server will try to resolve this malicious domain and make an HTTP request to it. Due to this, the attacker can monitor their own DNS or web server to confirm that the request was made. An attacker can use a domain they control (for example, `attacker.com`) and configure DNS records to record all DNS queries made to that domain. Then, inject a URL like `http://unique-id.attacker.com`. If the server is vulnerable, it will try to resolve this domain (generating a DNS request) and then make an HTTP request, the attacker will see an entry in their records, confirming the vulnerability.

In addition, services such as [Canarytokens](https://canarytokens.org/generate){:target="_blank"} can be used to generate unique tokens that alert when they are accessed.

## How to Prevent SSRF Attacks

As we have seen previously, this type of attack is particularly dangerous, facilitating the exploitation of internal or external resources of a server. To protect against this type of vulnerability, it is essential to implement a combination of robust security measures. Below are the most effective strategies:

### **Strictly Validate Input**

To protect ourselves against a standard SSRF attack, we can make use of:

-   **Whitelists**: We can allow the server to access specific URLs that are reliable for the correct use of the application. Instead of allowing any URL, define a whitelist of domains and routes that the server can access. Any request that does not match this whitelist must be rejected. Example: `allowed = ["api.example.com/products", "images.example.com"]`.
-   **Blocking internal addresses**: We can block requests to internal URLs, so that internal server resources cannot be accessed (`localhost` or any IP like `192.168.x.x`). Configure the server to reject any request to private IP addresses (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) and to `localhost` (127.0.0.1). This prevents unauthorized access to internal network resources, preventing an attacker from manipulating the server to access services or data that should be protected. This prevents unauthorized access to internal network resources, preventing an attacker from manipulating the server to access services or data that should be protected.
-   **Restricting protocols**: We can block protocols such as **ftp://**, **file://**, among others. Limiting protocols to HTTP(S) reduces the attack surface, preventing other potentially insecure protocols from being used to access internal or external resources.

### **Use of Web Application Firewalls (WAFs)**

Configuring a WAF with specific rules can help detect and block suspicious patterns related to SSRF. WAFs can act as an additional layer of defense by monitoring and filtering the server's outgoing traffic. Examples of WAF rules:

-   Block any request that contains `127.0.0.1` or `localhost` in the URL.
-   Block requests that use protocols like `file://`, `ftp://`, `gopher://`.
-   Block requests to private IP addresses.

### **Network Segmentation**

Divide the network into segments and limit access between them. For example, if the web server should not have direct access to the database, because it makes use of an API. Then, the ability to send traffic directly to the database server should be limited. This approach should be adapted to the specific situation, although in general the host should not be able to access more internal services than strictly necessary for its operation, minimizing the attack surface.

### **Use of Out-of-Band (OOB) Techniques**

Although blind SSRF does not show responses directly to the attacker, out-of-band techniques leave traces that can help detect malicious attempts. In order to detect these techniques, it is crucial to configure the monitoring of DNS requests issued by application servers in order to identify unexpected requests to external domains.

### **Periodic Security Testing**

Perform regular security audits to protect your web applications against this and other threats.

## Conclusion

Preventing SSRF attacks requires a layered security approach, combining input validation, the use of WAFs, regular updates, network segmentation, and security testing. By implementing these measures, you can significantly reduce the risk of your infrastructure being compromised by this dangerous vulnerability. Remember that security is an ongoing process, and it is important to stay updated on the latest vulnerabilities and attack techniques.

--- 